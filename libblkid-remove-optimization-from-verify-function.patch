From 2270b1ad90b394950f4fe215eb2fc1042020cef0 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Fri, 1 Feb 2013 15:59:58 +0100
Subject: [PATCH] libblkid: remove optimization from verify( funrtion

Now libblkid (the cache based part) tries to probe for the cached
filesystem firstly. This optimization is broken, because:

  * new another superblock could be on the device and the original
    is already obsolete
  * we still need to probe for partitions and raids
  * the code was too fragile

The patch also suggests lsblk --fs in blkid.8 for end users. lsblk
read information from used db.

Reported-by: Andreas Hofmeister <andi@collax.com>
Signed-off-by: Karel Zak <kzak@redhat.com>
---
 libblkid/src/verify.c | 76 ++++++++-------------------------------------------
 misc-utils/blkid.8    | 11 ++++++++
 2 files changed, 22 insertions(+), 65 deletions(-)

diff --git a/libblkid/src/verify.c b/libblkid/src/verify.c
index 4bab4de..0f48c48 100644
--- a/libblkid/src/verify.c
+++ b/libblkid/src/verify.c
@@ -43,26 +43,6 @@ static void blkid_probe_to_tags(blkid_probe pr, blkid_dev dev)
 			blkid_set_tag(dev, name, data, len);
 		}
 	}
-
-	/*
-	 * remove obsolete tags
-	 */
-	if (!nvals || !blkid_probe_has_value(pr, "LABEL"))
-		blkid_set_tag(dev, "LABEL", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "UUID"))
-		blkid_set_tag(dev, "UUID", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "PART_ENTRY_UUID"))
-		blkid_set_tag(dev, "PARTUUID", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "PART_ENTRY_NAME"))
-		blkid_set_tag(dev, "PARTLABEL", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "TYPE"))
-		blkid_set_tag(dev, "TYPE", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "SEC_TYPE"))
-		blkid_set_tag(dev, "SEC_TYPE", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "EXT_JOURNAL"))	/* extN */
-		blkid_set_tag(dev, "EXT_JOURNAL", NULL, 0);
-	if (!nvals || !blkid_probe_has_value(pr, "MOUNT"))		/* ocfs */
-		blkid_set_tag(dev, "MOUNT", NULL, 0);
 }
 
 /*
@@ -76,9 +56,10 @@ static void blkid_probe_to_tags(blkid_probe pr, blkid_dev dev)
  */
 blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev)
 {
+	blkid_tag_iterate iter;
+	const char *type, *value;
 	struct stat st;
 	time_t diff, now;
-	char *fltr[2];
 	int fd;
 
 	if (!dev)
@@ -155,64 +136,29 @@ blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev)
 		return NULL;
 	}
 
-	blkid_probe_enable_superblocks(cache->probe, TRUE);
+	/* remove old cache info */
+	iter = blkid_tag_iterate_begin(dev);
+	while (blkid_tag_next(iter, &type, &value) == 0)
+		blkid_set_tag(dev, type, NULL, 0);
+	blkid_tag_iterate_end(iter);
 
+	/* enable superblocks probing */
+	blkid_probe_enable_superblocks(cache->probe, TRUE);
 	blkid_probe_set_superblocks_flags(cache->probe,
 		BLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID |
 		BLKID_SUBLKS_TYPE | BLKID_SUBLKS_SECTYPE);
 
-	/*
-	 * If we already know the type, then try that first.
-	 */
-	if (dev->bid_type) {
-		blkid_tag_iterate iter;
-		const char *type, *value;
-
-		fltr[0] = dev->bid_type;
-		fltr[1] = NULL;
-
-		blkid_probe_filter_superblocks_type(cache->probe,
-				BLKID_FLTR_ONLYIN, fltr);
-
-		if (blkid_do_probe(cache->probe) == 0) {
-			/*
-			 * Cool, we found FS type, let's also read PART{UUID,LABEL}
-			 */
-			blkid_probe_enable_superblocks(cache->probe, FALSE);
-			blkid_probe_enable_partitions(cache->probe, TRUE);
-			blkid_probe_set_partitions_flags(cache->probe, BLKID_PARTS_ENTRY_DETAILS);
-			if (blkid_do_probe(cache->probe) == 0)
-				goto found_type;
-		}
-
-		blkid_probe_enable_superblocks(cache->probe, TRUE);
-		blkid_probe_invert_superblocks_filter(cache->probe);
-
-		/*
-		 * Zap the device filesystem information and try again
-		 */
-		DBG(DEBUG_PROBE,
-		    printf("previous fs type %s not valid, "
-			   "trying full probe\n", dev->bid_type));
-		iter = blkid_tag_iterate_begin(dev);
-		while (blkid_tag_next(iter, &type, &value) == 0)
-			blkid_set_tag(dev, type, 0, 0);
-		blkid_tag_iterate_end(iter);
-	}
-
+	/* enable partitions probing */
 	blkid_probe_enable_partitions(cache->probe, TRUE);
 	blkid_probe_set_partitions_flags(cache->probe, BLKID_PARTS_ENTRY_DETAILS);
 
-	/*
-	 * Probe for all types.
-	 */
+	/* probe */
 	if (blkid_do_safeprobe(cache->probe)) {
 		/* found nothing or error */
 		blkid_free_dev(dev);
 		dev = NULL;
 	}
 
-found_type:
 	if (dev) {
 #ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
 		struct timeval tv;
diff --git a/misc-utils/blkid.8 b/misc-utils/blkid.8
index 2ba1ab4..eb8d716 100644
--- a/misc-utils/blkid.8
+++ b/misc-utils/blkid.8
@@ -64,6 +64,17 @@ library.  It can determine the type of content (e.g. filesystem or swap)
 that a block device holds, and also attributes (tokens, NAME=value pairs)
 from the content metadata (e.g. LABEL or UUID fields).
 .PP
+Note that
+.B blkid
+reads information directly from devices and for non-root users
+it returns cached unverified information. It's better to use
+.B lsblk --fs
+to get user-friendly overview about filesystems and devices. 
+.BR lsblk (8)
+is also easy to use in scripts.
+.B blkid
+is mostly designed for system services and to test libblkid functionality.
+.PP
 .B blkid
 has two main forms of operation: either searching for a device with a
 specific NAME=value pair, or displaying NAME=value pairs for one or
-- 
1.8.1

